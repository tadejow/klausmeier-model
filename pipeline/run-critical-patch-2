using LinearAlgebra
using Plots
using ProgressMeter
using LaTeXStrings
using SpecialFunctions

# =========================================================================
# 1. DISCRETIZATION STRUCTS & OPERATORS (Same as before)
# =========================================================================

struct IntegralOperator
    kernel::Matrix{Float64}
    weights::Vector{Float64}
end

function IntegralOperator(x::AbstractVector, kernel_func::Function)
    dx = x[2] - x[1]
    grid_x = [i for i in x, j in x]
    grid_y = [j for i in x, j in x]
    kernel = kernel_func.(grid_x, grid_y)
    weights = ones(length(x))
    weights[begin] *= 0.5
    weights[end] *= 0.5
    weights .*= dx
    return IntegralOperator(kernel, weights)
end

function compute(op::IntegralOperator, u::AbstractVector)
    return (op.kernel * (u .* op.weights))
end

struct LaplacianFD
    D2::Matrix{Float64}
end

function LaplacianFD(x::AbstractVector)
    N = length(x)
    dx = x[2] - x[1]
    D2 = diagm(0 => -2 * ones(N), 1 => ones(N - 1), -1 => ones(N - 1)) / dx^2
    return LaplacianFD(D2)
end

function compute(op::LaplacianFD, u::AbstractVector)
    return op.D2 * u
end

# =========================================================================
# 2. KERNEL DEFINITIONS
# =========================================================================

function kernel_fat(x, y)
    dist = abs(x - y)
    return (1.0 / sqrt(2.0)) * exp(-sqrt(2.0) * dist)
end

const g34 = gamma(0.75)
const g14 = gamma(0.25)
const J2_C1 = 2.0 * (sqrt(g34) / (g14^1.5))
const J2_C2 = (g34 / g14)^2

function kernel_thin(x, y)
    dist = abs(x - y)
    return J2_C1 * exp(-J2_C2 * dist^4)
end

# =========================================================================
# 3. SIMULATION LOGIC
# =========================================================================

function run_simulation(L, N, u_init, v_init, op_type, operator)
    A, B, d_u, d_v = 1.8, 0.45, 2.0, 0.1
    ht = 0.0001
    tol = 1e-5
    max_iter = 500000

    u_old = copy(u_init)
    v_old = copy(v_init)
    u_old[begin] = u_old[end] = 0
    v_old[begin] = v_old[end] = 0
    
    dx = 2L / (N-1)

    for j in 1:max_iter
        if op_type == :integral
            u_spatial = d_u * compute(operator, u_old) - d_u * u_old
        else
            u_spatial = (d_u / 2) * compute(operator, u_old)
        end

        w_spatial = zeros(N)
        w_spatial[2:end-1] = (v_old[3:end] - 2*v_old[2:end-1] + v_old[1:end-2]) / dx^2
        w_spatial .*= d_v

        u_reac = u_old.^2 .* v_old .- B .* u_old
        v_reac = .- u_old.^2 .* v_old .- v_old .+ A

        u_new = u_old .+ ht .* (u_spatial .+ u_reac)
        v_new = v_old .+ ht .* (w_spatial .+ v_reac)

        u_new[begin] = u_new[end] = 0
        v_new[begin] = v_new[end] = 0

        if norm(u_new - u_old) < tol
            biomass = sum(u_new) / length(u_new)
            return biomass, hcat(collect(range(-L, L, length=N)), u_new)
        end

        if any(isnan, u_new) || any(isnan, v_new)
            return NaN, nothing
        end

        u_old, v_old = u_new, v_new
    end
    return NaN, nothing
end

# =========================================================================
# 4. EXECUTION
# =========================================================================

println("Starting simulations...")

const K = 50 
const L_min, L_max = 1.0, 100.0
const A_p, B_p = 1.8, 0.45
const v_star = (A_p + sqrt(A_p^2 - 4*B_p^2)) / (2 * B_p)
const w_star = (2 * B_p^2) / (A_p + sqrt(A_p^2 - 4*B_p^2))

L_vals = exp.(range(log(L_min), log(L_max), length=K))

res = Dict(
    :fat => (zeros(K), Vector{Any}(undef, K)),
    :thin => (zeros(K), Vector{Any}(undef, K)),
    :local => (zeros(K), Vector{Any}(undef, K))
)

@showprogress "Computing..." for (i, L) in enumerate(L_vals)
    N = max(50, floor(Int, 20 * L)) 
    x_domain = range(-L, L, length=N)
    u_init = ones(N) .* v_star
    v_init = ones(N) .* w_star
    
    op_fat = IntegralOperator(x_domain, kernel_fat)
    b_fat, v_fat = run_simulation(L, N, u_init, v_init, :integral, op_fat)
    res[:fat][1][i] = b_fat
    res[:fat][2][i] = v_fat

    op_thin = IntegralOperator(x_domain, kernel_thin)
    b_thin, v_thin = run_simulation(L, N, u_init, v_init, :integral, op_thin)
    res[:thin][1][i] = b_thin
    res[:thin][2][i] = v_thin

    op_lap = LaplacianFD(x_domain)
    b_loc, v_loc = run_simulation(L, N, u_init, v_init, :local, op_lap)
    res[:local][1][i] = b_loc
    res[:local][2][i] = v_loc
end

# =========================================================================
# 5. ANALYSIS AND PLOTTING
# =========================================================================

zero_threshold = 0.1
# Standardize font size
f_size = 12 

function find_crit(L_arr, b_arr)
    idx = findlast(b -> !isnan(b) && b < zero_threshold, b_arr)
    return isnothing(idx) ? NaN : L_arr[idx]
end

L_crit_fat = find_crit(L_vals, res[:fat][1])
L_crit_thin = find_crit(L_vals, res[:thin][1])
L_crit_loc = find_crit(L_vals, res[:local][1])

plot_layout = @layout [a{0.6w} grid(3,3)]

# --- Main Plot ---
p_main = plot(
    title="Critical Patch Size for Different Dispersal Kernels",
    xaxis=("Patch half-width L", :log),
    yaxis="Average biomass density",
    legend=:bottomright, 
    gridalpha=0.4,
    # Consistent Fonts
    titlefontsize=f_size, 
    tickfontsize=f_size, 
    legendfontsize=f_size, # Adjusted to avoid overlapping labels
    guidefontsize=f_size,
    ylims=(-0.1, 4.0)
)

# Plot Data
plot!(p_main, L_vals, res[:local][1], label="Local", 
      color=:navy, marker=:circle, markersize=3, linealpha=0.8)
plot!(p_main, L_vals, res[:thin][1], label="Non-local (Thin Tails)", 
      color=:cyan, marker=:circle, markersize=3, linealpha=0.8)
plot!(p_main, L_vals, res[:fat][1], label="Non-local (Fat Tails)", 
      color=:orange, marker=:circle, markersize=3, linealpha=0.8)

# Reference Line
hline!(p_main, [v_star], label="Spatially uniform solution", 
       color=:red, linestyle=:dash)

# Annotations (Vertical Lines + Text)
function add_crit_line!(p, val, col, text_y, align, shift_factor)
    if !isnan(val)
        vline!(p, [val], color=col, linestyle=:dash, label="")
        # Shift text slightly relative to the line (0.9 for left, 1.1 for right)
        annotate!(p, val * shift_factor, text_y, 
                  text("L_crit = $(round(val, digits=2))", col, align, f_size))
    end
end

# 1. Fat Tails (Orange) - Left of line, Top Position
add_crit_line!(p_main, L_crit_fat, :orange, 3.5, :left, 0.4)

# 2. Thin Tails (Cyan) - Left of line, Lower Position (Stacked)
add_crit_line!(p_main, L_crit_thin, :cyan, 3.0, :left, 0.3)

# 3. Local (Blue) - Right of line
add_crit_line!(p_main, L_crit_loc, :navy, 2.5, :left, 0.2)

# --- Side Plots (Profiles) ---
side_plots = []
L_targets = [1.46, 2.56, 3.39, 4.09, 4.94, 9.54, 20.24, 51.79, 100.0]

for (i, target_L) in enumerate(L_targets)
    _, idx = findmin(abs.(L_vals .- target_L))
    act_L = L_vals[idx]
    
    # Custom 3 Ticks
    L_rnd = round(act_L, digits=2)
    tick_pos = [-act_L, 0.0, act_L]
    tick_lab = ["-$(L_rnd)", "0", "$(L_rnd)"]

    sp = plot(title="L = $L_rnd", 
              ylims=(-0.1, 4.5), 
              xticks=(tick_pos, tick_lab),
              gridalpha=0.3, legend=false,
              titlefontsize=f_size, 
              tickfontsize=f_size,
              guidefontsize=f_size
    )

    # SCATTER PLOTS (Markers only)
    for (key, col) in [(:local, :navy), (:thin, :cyan), (:fat, :orange)]
        data = res[key][2][idx]
        if data !== nothing
            # Use scatter! instead of plot!
            scatter!(sp, data[:,1], data[:,2], 
                     color=col, 
                     marker=:circle,
                     markersize=3, # Small markers for density
                     markerstrokewidth=0.8)
        end
    end
    
    hline!(sp, [v_star], color=:red, linestyle=:dash, lw=1)

    if i == 4; ylabel!(sp, "Biomass"); end
    if i >= 7; xlabel!(sp, "x"); end

    push!(side_plots, sp)
end

final_plot = plot(p_main, side_plots..., layout=plot_layout, size=(1200, 800), margin=5Plots.mm)
display(final_plot)